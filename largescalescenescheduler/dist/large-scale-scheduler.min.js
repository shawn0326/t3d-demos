!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).t3d=e.t3d||{},e.t3d)}(this,(function(e,t){"use strict";class s extends t.EventDispatcher{constructor(e=1e3,t=!1){super(),this._maxLimitCount=e,this._allocatedCount=0,this._allocatedAndActiveTailIndex=-1,this._map=new Map,this._reverseMap=new Map,this._isTriggering=t,this._taskQueue=new Map}set maxLimitCount(e){this._maxLimitCount=e}get maxLimitCount(){return this._maxLimitCount}get allocatedCount(){return this._allocatedCount}get activeCount(){return this._allocatedAndActiveTailIndex+1}getIndex(e){return this._map.has(e)?this._map.get(e):(console.warn("IndicesManager: Index not found, will attempt to allocate.."),this.allocateIndex(e))}hasIndex(e){return this._map.has(e)}allocateIndex(e,t=!1){if(this._map.has(e))return console.warn("IndicesManager: Index already allocated."),this._map.get(e);let s=this._allocatedCount;return this._allocatedCount++,this._allocatedCount>this._maxLimitCount&&(console.warn("IndicesManager: Max limit is <"+this._maxLimitCount+"> ."),s--,this._allocatedCount--),this._map.set(e,s),this._reverseMap.set(s,e),t?this.activateIndex(e):this.deactivateIndex(e),s}releaseIndex(e,t=!1){if(!this._map.has(e))return!1;if(this._isTriggering&&t)return void this._taskQueue.set(e,"releaseIndex");this.deactivateIndex(e);const s=this._allocatedCount-1,i=this._map.get(e);return this._map.delete(e),this._reverseMap.delete(i),this._allocatedCount--,this.moveIndex(s,i),!0}moveIndex(e,t){if(e===t)return!1;const s=this._reverseMap.get(e);return this._map.set(s,t),this._reverseMap.set(t,s),this.dispatchEvent({type:i.INDEX_CHANGED,sourceIndex:e,targetIndex:t}),!0}swapIndex(e,t){if(e===t)return!1;const s=this._reverseMap.get(e),n=this._reverseMap.get(t);return this._map.set(s,t),this._map.set(n,e),this._reverseMap.set(e,n),this._reverseMap.set(t,s),this.dispatchEvent({type:i.INDEX_CHANGED,sourceIndex:e,targetIndex:t}),!0}activateIndex(e,t=!1){if(!this._map.has(e))return!1;if(this._isTriggering&&t)return void this._taskQueue.set(e,"activateIndex");const s=this._map.get(e);if(s>this._allocatedAndActiveTailIndex){this._allocatedAndActiveTailIndex++;this.swapIndex(s,this._allocatedAndActiveTailIndex)||this.dispatchEvent({type:i.ACTIVE_COUNT_CHANGED,activeCount:this.activeCount})}return!0}deactivateIndex(e,t=!1){if(!this._map.has(e))return!1;if(this._isTriggering&&t)return void this._taskQueue.set(e,"deactivateIndex");const s=this._map.get(e);if(s<=this._allocatedAndActiveTailIndex){this._allocatedAndActiveTailIndex--;this.swapIndex(this._allocatedAndActiveTailIndex+1,s)||this.dispatchEvent({type:i.ACTIVE_COUNT_CHANGED,activeCount:this.activeCount})}return!0}triggerQueue(){this._isTriggering&&(this._taskQueue.forEach(((e,t)=>{switch(e){case"releaseIndex":this.releaseIndex(t);break;case"activateIndex":this.activateIndex(t);break;case"deactivateIndex":this.deactivateIndex(t)}})),this._taskQueue.clear())}clear(){this._allocatedCount=0,this._allocatedAndActiveTailIndex=-1,this._map.clear(),this._reverseMap.clear(),this.dispatchEvent({type:i.ACTIVE_COUNT_CHANGED,activeCount:this.activeCount})}}const i={INDEX_CHANGED:"IndexChanged",ACTIVE_COUNT_CHANGED:"ActiveCountChanged"};class n{constructor(e=new t.Box3,s=0){this.box=e,this.depth=s,this.subTrees=[],this.elements=[],this.elementTest=function(e,t){return e.containsPoint(t)}}isEmpty(){return 0===this.elements.length&&0===this.subTrees.length}divideElements(e=5,t=8){const{depth:s,subTrees:i,elements:n,elementTest:r}=this;if(s>=e||n.length<=t)return;this.subdivide();let a=this.elements.pop();for(;a;){for(let e=0;e<i.length;e++)r(i[e].box,a)&&i[e].elements.push(a);a=this.elements.pop()}i.forEach((s=>s.divideElements(e,t)))}addElement(e,t=5,s=8){const{box:i,depth:n,subTrees:r,elements:a,elementTest:o}=this;if(!o(i,e))return!1;if(0===r.length)return a.push(e),a.length>s&&n<t&&this.divideElements(t,s),!0;for(let i=0;i<r.length;i++)if(r[i].addElement(e,t,s))return!0}removeElement(e){const t=this.elements,s=t.indexOf(e);if(-1!==s)return t.splice(s,1),!0;const i=this.subTrees;for(let t=0;t<i.length;t++)if(i[t].removeElement(e))return!0;return!1}subdivide(){const e=a.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);r.forEach(((s,i)=>{const n=new t.Box3;n.min.copy(this.box.min).add(o.copy(s).multiply(e)),n.max.copy(n.min).add(e),this.subTrees[i]=new this.constructor(n,this.depth+1)}))}count(){let e=1;for(let t=0;t<this.subTrees.length;t++)e+=this.subTrees[t].count();return e}}const r=[new t.Vector3(0,0,0),new t.Vector3(0,0,1),new t.Vector3(0,1,0),new t.Vector3(0,1,1),new t.Vector3(1,0,0),new t.Vector3(1,0,1),new t.Vector3(1,1,0),new t.Vector3(1,1,1)],a=new t.Vector3,o=new t.Vector3;class c extends n{constructor(e,t=0){super(e,t)}subdivide(){const e=d.copy(this.box.max).sub(this.box.min).multiplyScalar(.5);e.y*=2,h.forEach(((s,i)=>{const n=new t.Box3;n.min.copy(this.box.min).add(u.copy(s).multiply(e)),n.max.copy(n.min).add(e),this.subTrees[i]=new this.constructor(n,this.depth+1)}))}}const h=[new t.Vector3(0,0,0),new t.Vector3(0,0,1),new t.Vector3(1,0,0),new t.Vector3(1,0,1)],d=new t.Vector3,u=new t.Vector3;class l{constructor(e,s={}){const i=void 0!==s.treeType?s.treeType:"octree",n=void 0!==s.maxDepth?s.maxDepth:1/0,r=void 0!==s.capacity?s.capacity:25;this.enabled=!0,this.distance=2e3,this._maxDepth=n,this._capacity=r,this._tree="octree"===i?new _:new m,this._tree.box.copy(e),this._cameraStates={position:new t.Vector3,frustum:new t.Frustum}}addLOD(e){this._tree.addElement(e,this._maxDepth,this._capacity)}removeLOD(e){this._tree.removeElement(e)}getTree(){return this._tree}update(e){this.enabled&&(this._updateCameraStates(e),this._updateLODs(this._tree))}_updateCameraStates(e){const t=this._cameraStates.position,s=this._cameraStates.frustum;t.setFromMatrixPosition(e.worldMatrix),p.multiplyMatrices(e.projectionMatrix,e.viewMatrix),s.setFromMatrix(p);const i=s.planes[5],n=s.planes[4];n.normal.copy(i.normal).negate(),n.constant=-i.constant+this.distance}_updateLODs(e){const t=this._cameraStates.position,s=this._cameraStates.frustum;if(!s.intersectsBox(e.box))return void this._hideLODs(e);e.inactive=!1;const i=e.elements;for(let e=0,n=i.length;e<n;e++){const n=i[e],r=n.boundingSphere;if(s.intersectsSphere(r)){const e=t.distanceToSquared(r.center);n.show(e)}else n.hide()}if(e.subTrees.length>0)for(let t=0,s=e.subTrees.length;t<s;t++)this._updateLODs(e.subTrees[t])}_hideLODs(e){if(e.inactive)return;const t=e.elements;for(let e=0,s=t.length;e<s;e++)t[e].hide();if(e.subTrees.length>0)for(let t=0,s=e.subTrees.length;t<s;t++)this._hideLODs(e.subTrees[t]);e.inactive=!0}dispose(){this._tree=null,this._cameraStates=null}}const p=new t.Matrix4;class _ extends n{constructor(e,t){super(e,t),this.elementTest=function(e,t){return e.containsPoint(t.boundingSphere.center)},this.inactive=!1}}class m extends c{constructor(e,t){super(e,t),this.elementTest=function(e,t){return e.containsPoint(t.boundingSphere.center)},this.inactive=!1}}class x{constructor(e=new t.Matrix4,s=0){this.worldMatrix=new t.Matrix4,this.boundingSphere=new t.Sphere,this.worldMatrix.copy(e),this.boundingSphere.radius=s,this.boundingSphere.center.setFromMatrixPosition(this.worldMatrix)}show(e){}hide(){}}class g extends x{constructor(e,t=[]){super(e.worldMatrix,e.radius),this.id=e.id,this.name=e.name,this.objects=t,this._currentRange={level:-1,start:-1,end:-1}}show(e){const t=this.objects,s=this._currentRange;if(s.level>-1&&e>=s.start&&e<=s.end)return;let i,n;for(i=1,n=t.length;i<n&&e>=t[i].distanceSq;i++)t[i-1].setVisible(!1);for(t[i-1].setVisible(!0),s.level=i-1,s.start=1===i?0:t[i-1].distanceSq,s.end=i===n?1/0:t[i].distanceSq;i<n;i++)t[i].setVisible(!1)}hide(){const e=this.objects,t=this._currentRange;for(let t=0,s=e.length;t<s;t++)e[t].setVisible(!1);t.level=-1}dispose(){this.objects=[]}}class v{constructor(e,n){const r=[];e.traverse((e=>{e.isMesh&&r.push(e.geometry)}));const a=new s(n,!0),o=new I(new Float32Array(16*n),16),c=new t.Attribute(o);c.divisor=1,r.forEach((e=>{e.addAttribute("instanceMatrix",c)})),a.addEventListener(i.INDEX_CHANGED,(t=>{const s=t.sourceIndex,i=t.targetIndex;o.swap(s,i),r.forEach((e=>{e.instanceCount=a.activeCount})),e.visible=0!==a.activeCount})),a.addEventListener(i.ACTIVE_COUNT_CHANGED,(t=>{const s=t.activeCount;r.forEach((e=>{e.instanceCount=s})),e.visible=0!==s})),this._indicesManager=a,this._buffer=o}add(e,t){const s=this._indicesManager.allocateIndex(e,!1);t.toArray(this._buffer.array,16*s)}remove(e){this._indicesManager.releaseIndex(e,!0)}setVisible(e,t){t?this._indicesManager.activateIndex(e,!0):this._indicesManager.deactivateIndex(e,!0)}flush(){this._indicesManager.triggerQueue()}dispose(){this._indicesManager.clear()}}const f=new t.Matrix4,b=new t.Matrix4;class I extends t.Buffer{constructor(e,t){super(e,t)}swap(e,t){const s=this.stride,i=e*s,n=t*s,r=this.array;f.fromArray(r,n),b.fromArray(r,i),f.toArray(r,i),b.toArray(r,n),this._expandUpdateRange(t),this.version++}_expandUpdateRange(e){const t=this.updateRange,s=this.stride,i=e*s;if(-1===t.count)return t.offset=i,void(t.count=s);const n=t.offset,r=n+t.count;t.offset=Math.min(n,i),t.count=Math.max(r,i+s)-t.offset}}t.Box3.prototype.getSize=function(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)},t.Box3.prototype.containsPoint=function(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)},e.LOD=x,e.LargeScaleInstancedManager=class{constructor(e,t={}){this.scheduler=new l(e,t),this._resources=new Map}registerResource(e,t){if(this._resources.has(e))return void console.warn("LargeScaleInstancedManager: Resource already registered.");const s=new v(t.node,t.maxCount);this._resources.set(e,s)}unRegisterResource(e){const t=this._resources.get(e);t&&(t.dispose(),this._resources.delete(e))}_createInstancedNode(e,t,s){const i=t.worldMatrix,n={distanceSq:s*s||0,visible:!1,disposed:!1,setVisible:function(t){this.visible!==t&&(this.visible=t,e.setVisible(this,t))},dispose:function(){this.disposed||(this.disposed=!0,e.remove(this))}};return e.add(n,i),n}createInstancedLODNode(e){const t=this._resources,s=e.types,i=e.distances,n=[];for(let r=0,a=s.length;r<a;r++){const a=s[r],o=t.get(a);if(!o){console.warn(`LargeScaleInstancedScene: Resource type ${a} not registered.`);continue}const c=this._createInstancedNode(o,e,i[r]);n.push(c)}const r=new g(e,n);return this.scheduler.addLOD(r),r}destroyInstancedLODNode(e){this.scheduler.removeLOD(e);const t=e.objects;for(let e=0,s=t.length;e<s;e++)t[e].dispose()}update(e){this.scheduler.update(e),this._resources.forEach((e=>{e.flush()}))}dispose(){this.scheduler.dispose(),this.scheduler=null,this._resources.forEach((e=>{e.dispose()})),this._resources.clear(),this._resources=null}},e.Scheduler=l}));
